#ifndef _GA_QAP_H_
#define _GA_QAP_H_

#include <algorithm>
#include <climits> // INT_MAX
#include <iostream>
#include <utility>
#include <vector>
#include "qap.h"

struct Individual
{
	int n;
	int* perm;
	int fitness;

	Individual() : Individual(-1, (int*)nullptr, -1) {}

	Individual(int n, int* perm) : fitness(-1) {this->n = n; this->perm = perm;}

	Individual(int n, int* perm, int fitness) {this->n = n; this->perm = perm; this->fitness = fitness;}

	Individual(const Individual& other) 
	{
		this->n = other.n;
		this->fitness = other.fitness;

		if(other.perm != (int*)nullptr)
		{
			this->perm = new int[this->n];
			std::copy(other.perm, other.perm + this->n, this->perm);
		}

		else
			this->perm = (int*)nullptr;
	}

	~Individual(){delete[] perm;}

	Individual& operator=(const Individual& other)
	{
		this->n = other.n;
		this->fitness = other.fitness;

		if(other.perm != (int*)nullptr)
		{
			if(this->perm != (int*)nullptr)
				delete[] this->perm;
				
			this->perm = new int[this->n];
			std::copy(other.perm, other.perm + n, this->perm);
			
		}

		else
		{
			if(this->perm != (int*)nullptr)
				delete[] this->perm;

			this->perm = (int*)nullptr;
		}

		return *this;
	}
};

class GA_QAP 
{
	private:
		int size_initial_population;

		std::vector<Individual> population;

		/** instance size of QAP */
		int size_problem;

		QAP *problem;

		/**
		 * mutation rate, initial with 20%
		 */
		int mutation_rate;

		Individual current_best_individual;

		int fitness_of_current_best_individual;

		bool improved;

		int position_local_optimization = 0;

		void improve_solution ( int index );

		void swap_position_on_population(Individual& individual, int f1, int f2);

	public:

		/**
		 * @brief      Constructs the object.
		 *
		 * @param      problem       The problem
		 * @param[in]  size_problem  The size problem
		 */
		GA_QAP(QAP *problem, int size_initial_population);

		/**
		 * @brief      Generates an initial population randomly
		 */
		void generate_initial_population();

		/**
		 * @brief      Randomly select two individuals to apply crossover
		 *
		 * @return     the new individual generated
		 */
		void selection ();

		/**
		 * @brief      Producing a new feasible solution (i.e., a child) 
		 			   by combining two individuals. 
		 *
		 * @param      i     the father
		 * @param      j     the mother
		 *
		 * @return     the new individual generated by combining i and j
		 */
		Individual crossover(Individual& mother, Individual& father);

		/**
		 * @brief       Increasing diversity in the population by introducing
		 				random variations in the members of the population. 
		 */
		void mutation();

		/**
		 * @brief      realize a swap number 1 with number 2 in individual
		 *
		 * @param[in]  num1       The number 1
		 * @param[in]  num2       The number 2
		 * @param[in]  individual The individual
		 */
		void swap(int num1, int num2, int* perm_individual);

		void verify_condition_path_swap (int* father, int* mother, int position);

		/**
		 * @brief      print the individuals of population
		 */
		void print_population();

		/**
		 * @brief      Determines if dominate.
		 *
		 * @param      individual  The individual
		 *
		 * @return     True if dominate, False otherwise.
		 */
		void set_as_best(Individual& individual);

		int get_fitness_current_best_solution();

		int * get_best_solution();

		/**
		 * @brief      optimizes 20% of the current population through 
		 *             a neighborhood search      
		 */
		void local_optimization (int current_iteration, int MUTATION_PERIOD);

		void run();

		int delta_value_linear(int i, int j, int* pi);

};


#endif